# Java多线程技能

## 1.1进程和线程概述

进程：.exe

线程：QQ的视频线程和下载线程和打字线程“同时”进行

## 1.2使用多线程

### 1.2.1继承Thread类

缺点：由于Java是单继承语法，所以继承Thread类后，不能实现多继承

Thread类实现了Runnable接口，它们之间具有多态关系。

start()方法耗时的原因：

1. 通过JVM告诉操作系统创建Thread
2. 操作系统开辟内存并使用Windows SDK中的`createThread()`函数创建Thread线程对象
3. 操作系统对Thread对象进行调度，以确定执行时机
4. Thread在操作系统中被成功执行

在使用多线程技术时，代码的运行结果和代码的执行顺序或调用顺序时无关的。另外，线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来电泳线程中的`run()`方法，所以先输出“运行结束”和先输出“MyThread”具有不确定性。

### 1.2.2使用常见命令分析线程的信息

1. jps+jstack.exe
2. jmc.exe
3. jvisualvm.exe

### 1.2.3线程随机性的展现

​	Thread.Java类中的start()方法通知"线程规划器——此线程已经准备就绪，准备调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，即让线程执行具体的仍无，具有随机顺序执行的结果。

​	如果调用代码“thread.run();”而不是“thread.start();”，其实就不是异步执行了，而是同步执行，那么此线程对象并不交给“线程规划器”来进行处理，而是由main主线程来调用run()方法，也就是等run()方法中的代码执行完毕后才可以执行后面的代码。

### 1.2.4执行start()的顺序不代表执行run()的顺序

​	注意，执行start()方法的顺序不代表线程启动的顺序。启动一个线程后，JVM直接调用MyThread.java类中的run()方法。

### 1.2.5实现Runnable接口

​	如果想创建的线程类已经有一个父类了，就不能再继承自Thread类，一i那位Java不支持多继承，所以需要实现Runnable接口来解决这样的情况。

